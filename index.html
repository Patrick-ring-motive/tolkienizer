<html>
  <head></head>
  <body>
    <div></div>
    <script>
      ReadableStream.prototype.gunzip = function gunzip() {
        return this.pipeThrough(new DecompressionStream("gzip"));
      };
      ReadableStream.prototype.text = async function text() {
        return await new Response(this).text();
      };

      (async () => {
        const res = await fetch("model.json.txt.gz");
        const model = JSON.parse(await res.body.gunzip().text());

        const lcs = function lcs(seq1, seq2) {
          "use strict";
          let arr1 = [...(seq1 ?? [])];
          let arr2 = [...(seq2 ?? [])];
          if (arr2.length > arr1.length) {
            [arr1, arr2] = [arr2, arr1];
          }
          const dp = Array(arr1.length + 1)
            .fill(0)
            .map(() => Array(arr2.length + 1).fill(0));
          const dp_length = dp.length;
          for (let i = 1; i !== dp_length; i++) {
            const dpi_length = dp[i].length;
            for (let x = 1; x !== dpi_length; x++) {
              if (arr1[i - 1] === arr2[x - 1]) {
                dp[i][x] = dp[i - 1][x - 1] + 1;
              } else {
                dp[i][x] = Math.max(dp[i][x - 1], dp[i - 1][x]);
              }
            }
          }
          return dp[arr1.length][arr2.length];
        };

        const stringify = (x) => {
          try {
            return JSON.parse(x);
          } catch {
            return String(x);
          }
        };

        const followCount = (model, key) => {
          if (!model[key]) return 0;
          return Object.keys(model[key]).length;
        };

        function getNextToken(keywords, model, tokens = []) {
          const strtok = stringify(tokens);
          let maxMatch = 0;
          let keyMatch = keywords;
          let matches = model[keywords];
          if (Math.random() > 0.9 || !matches) {
            for (const key in model) {
              if (maxMatch > 0 && Math.random() > 0.5) {
                continue;
              }
              const keylcs =
                (lcs(key, keywords) * Math.min(key.length, keywords.length)) /
                (Math.max(key.length, keywords.length) *
                  strtok.split(key).length);
              if (keylcs > maxMatch) {
                maxMatch = keylcs;
                keyMatch = key;
              }
            }
            matches = model[keyMatch];
          }

          if (Math.random() > 0.5) {
            matches = Object.fromEntries(Object.entries(matches).sort());
          }

          if (Math.random() > 0.8) {
            matches = Object.fromEntries(Object.entries(matches).reverse());
          }
          maxMatch = 0;
          for (const key in matches) {
            if (maxMatch > 0 && Math.random() > 0.5) {
              continue;
            }
            if (
              (matches[key] + followCount(model, key) * 0.01) /
                strtok.split(key).length >
              maxMatch
            ) {
              maxMatch = matches[key];
              keyMatch = key;
            }
          }
          return stringify(keyMatch);
        }

        const join = (x, y = "") => {
          try {
            return x.join(y);
          } catch {
            return String(y);
          }
        };

        function generate(prompt, model, context = []) {
          console.log(context.length);
          if (!prompt) {
            prompt = context[context.length - 1];
          }
          const seed1 = getNextToken(prompt, model, context);
          const seed2 = getNextToken(`${prompt} ${seed1}`, model, context);
          const out = [seed1, seed2];
          context.push(seed1);
          context.push(seed2);
          const tokens = context;
          while (join(out).split(/[\.\?\!]/).length < 10) {
            const nextToken = getNextToken(
              `${tokens[tokens.length - 2]} ${tokens[tokens.length - 1]}`,
              model,
              tokens,
            );
            tokens.push(nextToken);
            out.push(nextToken);
          }
          return out
            .join(" ")
            .replace(/\? [a-z]/g, (x) => x.toUpperCase())
            .replace(/\. [a-z]/g, (x) => x.toUpperCase())
            .replace(/\! [a-z]/g, (x) => x.toUpperCase());
        }

        const nextTime =
          globalThis.requestIdleCallback ??
          globalThis.requestAnimationFrame ??
          ((x) => setTimeout(x, 0));

        const nextIdle = () => new Promise((resolve) => nextTime(resolve));

        function generateStream(prompt, model, context = []) {
          return new ReadableStream({
            async start(controller) {
              if (!prompt) {
                prompt = context[context.length - 1];
              }
              const seed1 = getNextToken(prompt, model, context);
              const seed2 = getNextToken(`${prompt} ${seed1}`, model, context);
              const out = [seed1, seed2];
              context.push(seed1);
              context.push(seed2);
              const tokens = context;
              while (join(out).split(/[\.\?\!]/).length < 10) {
                await nextIdle();
                const nextToken = getNextToken(
                  `${tokens[tokens.length - 2]} ${tokens[tokens.length - 1]}`,
                  model,
                  tokens,
                );
                tokens.push(nextToken);
                out.push(nextToken);
                controller.enqueue(nextToken);
              }
              controller.close();
            },
          });
        }
        function appendText(text) {
          document.querySelector("div").innerHTML = (
            document.querySelector("div").innerHTML +
            " " +
            text
          )
            .replaceAll("_", " ")
            .replace(/\? [a-z]/g, (x) => x.toUpperCase())
            .replace(/\. [a-z]/g, (x) => x.toUpperCase())
            .replace(/\! [a-z]/g, (x) => x.toUpperCase());
        }
        let context = JSON.parse(localStorage.getItem("context") || "[]");
        appendText(join(context, " "));
        let prompt = ">Aragorn";
        appendText(prompt);
        const stream = generateStream(prompt, model, context);

        for await (const chunk of stream) {
          localStorage.setItem("context", JSON.stringify(context));
          appendText(chunk);
        }
      })();
    </script>
  </body>
</html>
